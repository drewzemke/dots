"$schema" = "https://jj-vcs.github.io/jj/latest/config-schema.json"

# NOTE: MAKE SURE YOU'RE EDITING THIS FILE IN ~/dots!

[user]
name = "Drew Deleón-Zemke"
email = "{{email}}"

[ui]
default-command = "log"
pager = ["delta", "--pager", "less -FRX", "--side-by-side"]
diff-formatter = ":git"

[remotes.origin]
# matches the `git_push_bookmark` template below
auto-track-bookmarks = "drew/*"

[revsets]
log = 'connected(@ | ancestors(trunk()..(visible_heads() & mine()), 2) | trunk())'

[revset-aliases]
# set all remote bookmarks (commits pushed to remote branches) to be immutable
'immutable_heads()' = "builtin_immutable_heads() | remote_bookmarks()"

# branches relevant to current working context (trunk + bookmark heads in current ancestry)
'my_branches()' = "trunk() | heads(::@- & bookmarks())"

# commits relative to head that have not be synced with remote yet
'fresh()' = "bookmarks()..first_parent(@)"

# commits are prepped and ready to be pushed 
'out()' = "remote_bookmarks()..bookmarks()"

# commits have just been fetched but not rebased
'inc()' = "first_parent(@)..my_branches()"

[aliases]
# move any bookmarks in ancestors forward to the previous commit
prep = ["bookmark", "move", "--from", "heads(::@- & bookmarks())", "--to", "@-"]

# get remote commit, but don't rebase them
fetch = ['git', 'fetch', '--all-remotes']

push = ['git', 'push']

# move all of the local commits that haven't been synced yet to be on top of trunk
evolve = ["rebase", "-s", "roots(trunk()..mutable())", "-d", "trunk()"]

all = ["log", "-r", "all()"]
fresh = ["log", "-r", "fresh()"]
out = ["log", "-r", "out()"]
inc = ["log", "-r", "inc()"]

[colors]
private_commit_prefix = "#ffb86c"

[extra]
private-prefixes = ["wip", "exp", "todo", "fixme", "xxx"]

[git]
# won't push these
private-commits = 'description(regex:"^(wip|exp|todo|fixme|xxx):")'

[template-aliases]
# helper function to highlight specified prefixes in commit messages
# private prefixes get an orange lock icon prepended
'highlight_prefixes(line)' = '''
coalesce(
  config("extra.private-prefixes").as_string_list().map(|prefix|
    if(line.lower().starts_with(prefix.lower() ++ ":"),
      label("private_commit_prefix", " ") ++ line,
      ""
    )
  ).join(""),
  line
)
'''

# use relative timestamps up to one day ago
"format_timestamp(timestamp)" = '''
if(timestamp.after("1 day ago"),
  timestamp.ago(),
  timestamp.format("%Y-%m-%d %H:%M")
)
'''

"in_branch(commit)" = 'commit.contained_in("immutable_heads()..bookmarks()")'

[templates]
git_push_bookmark = '"drew/push-" ++ change_id.short()'

# formats commit messages in log by highlighting configurable prefixes
log = '''
if(root,
  format_root_commit(self),
  label(if(current_working_copy, "working_copy"),
    concat(
      format_short_commit_header(self) ++ "\n",
      separate(" ",
        if(empty, label("empty", "(empty)")),
        if(description,
          highlight_prefixes(description.first_line()),
          label(if(empty, "empty"), description_placeholder)
        )
      ) ++ "\n"
    )
  )
)
'''

# shows changes in editor when editing commit description
draft_commit_description = '''
concat(
  coalesce(description, default_commit_description, "\n"),
  surround(
    "\nJJ: This commit contains the following changes:\n", "",
    indent("JJ:     ", diff.summary()),
  ),
  if(parents,
    surround(
      "\nJJ: Parent commit(s):\n", "\n",
      indent("JJ:     ",
        parents.map(|c|
          c.change_id().shortest() ++ " " ++ c.description().first_line()
        ).join("\nJJ:     ")
      )
    ),
    ""
  ),
  "\nJJ: ignore-rest\n",
  diff.git(),
)
'''

# a shorter commit summary (used in `jj status`, for example) that uses the `highlight_prefixes` util
commit_summary = '''
separate(" ",
  change_id.shortest(),
  commit_id.shortest(),
  if(empty, label("empty", "(empty)")),
  if(description,
    highlight_prefixes(description.first_line()),
    label(if(empty, "empty"), description_placeholder)
  )
) 
'''

# shows an empty diamond for commits that are mutable but ancestors of a bookmark
# meaning they'll be synced by the next push
log_node = '''
if(self && !current_working_copy && !immutable && !conflict && in_branch(self),
  "◇",
  builtin_log_node
)
'''
